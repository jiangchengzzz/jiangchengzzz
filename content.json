[{"title":"linux常用命令","date":"2018-07-24T05:49:24.000Z","path":"20180724/操作服务器常用命令/","text":"初衷 嗯，今天干了件坑爹的事情，给服务器清楚缓存时候，执行了rm -rf / 对，就是它，本来想着在当前目录下执行删除命令rm -rf ，谁知道咋就加了个/。嗯，后果就是删除了整个服务器根目录下的所有东西。 这也是由于对操作服务器命令理解不够清晰引起的，所以准备学习一波基本操作。 文件操作 cd 命令 进入指定目录或当前文件夹命令 cd 目录或者当前位置文件夹 ls 命令 查看指定目录或当前位置下有哪些文件和文件夹的命令 ls 选项 指定目录或当前位置 选项一般就是-l，可查看每个文件或文件夹的详细信息，例如权限、用户、属组、大小、创建时间等。 示例： （1）ls -l /home/weblogic : 查看/home/weblogic目录下每个文件或文件夹的详细信息。 （2）ls -l : 查看当前位置下每个文件或文件夹的详细信息。 查看当前路径 pwd mkdir 新建目录 mkdir 目录名 touch命令 创建空文件命令，用于在指定目录或当前位置下创建一个空文件。 touch 指定目录或当前位置的文件 vi命令 vi命令是文件打开命令，用于创建或修改指定目录或当前位置下的文件。 vi 指定目录或当前位置的文件 相关编辑操作： （1）输入数据：打开文件后点击i键则可在光标显示后面输入数据。 （2）保存数据并关闭文件：点击esc键退出编辑状态，再点击:键加wq后回车。 （3）关闭文件：如果在编辑状态，则先点击esc键退出编辑状态，再点击:键加q!后回 车。 cp拷贝文件 此命令用来将一个或多个源文件或者目录复制到指定的目的文件或目录。 它可以将单个源文件复制成一个指定文件名的具体的文件或一个已经存在的目录下， 该命令还支持同时复制多个文件，当一次复制多个文件时，目标文件参数必须是一个 已经存在的目录，否则将出现错误 cp 选项 源文件或目录 目的文件或目录 选项一般有： -i : 覆盖既有文件之前先询问用户。 -R/r : 递归处理，将指定目录下的所有文件与子目录一并处理。 -b : 覆盖已存在的文件目标前将目标文件备份。 选项一般有： -i : 覆盖既有文件之前先询问用户。 -R/r : 递归处理，将指定目录下的所有文件与子目录一并处理。 -b : 覆盖已存在的文件目标前将目标文件备份。 删除文件 rm 参数 文件 例：rm -rf /system/www/abc.html 例 rm -rf /（没错，是它，就是它）-r 表示递归 -f 表示强制删除 / 表示根目录 mv命令可以用来移动文件或者将文件改名，格式如下： mv 选项 源文件或目录 目标文件或目录 选项一般有： -b ：若需覆盖文件，则覆盖前先行备份。 -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖。 -i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖。 示例： （1）mv b1.txt b1.log : 将文件b1.txt重命名为b1.log。 （2）mv b1.log /home/test/b : 将b1.log文件移到目录b中。 （3）mv /home/test/a/*.txt /home/test/b : 将/home/test/a目录下所有txt文件移动到/home/test/b目录下。 删除一个目录rmdir dirname移动或重命名一个目录 mvdir dir1 dir2 ps命令 此命令用于查看进程，格式如下：ps 选项 过滤符 进程ID或名称选项常用的是-ef : 查看当前所有进程，加上grep过滤符可进行筛选。示例：ps –ef|grep tomcat : 查看有关tomcat的进程，获得该进程信息。 tar命令可以用来压缩文件与解压缩文件包，格式如下：tar 选项 压缩包名称 压缩文件或解压缩路径选项一般有：-c ：建立压缩档案。-x ：解压。-t ：查看内容。-r ：向压缩归档文件末尾追加文件。-u ：更新原压缩包中的文件。这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。-z ：有gzip属性的。-j ：有bz2属性的。-Z ：有compress属性的。-v ：显示所有过程。-O ：将文件解开到标准输出。下面的参数-f是必须的-f ：使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。示例：（1）tar -cvf txt.tar .txt : 将当前目录下的所有txt文件压缩成txt.tar包。（2）tar -czvf txt.tar.gz .txt : 将当前目录下的所有txt文件压缩成txt.tar.gz包。（3）tar -xvf txt.tar : 在当前目录下解压txt.tar包。（4）tar -xzvf txt.tar.gz : : 在当前目录下解压txt.tar.gz包","tags":[{"name":"服务器","slug":"服务器","permalink":"https://jiangchengzzz.github.io/tags/服务器/"},{"name":"linux","slug":"linux","permalink":"https://jiangchengzzz.github.io/tags/linux/"}]},{"title":"用react-create-app来搭建-1","date":"2018-07-16T02:18:42.000Z","path":"20180716/react-create-app-1/","text":"初衷嗯，作为一个react小白，前几天用webpack搭建react环境，弄得头大，还有问题没解决。 所以我决定先学习react，最好的方式就是用脚手架搭建好，直接，快速的学习react。 开始 嗯，git瞄了一眼react-create-app的star最多，嗯就是你了， 那就引入。 1npm install -g create-react-app 生成项目。 12create-react-app react-clicd react-cli/ 然后npm start 默认情况下，会在开发环境下启动一个服务器，监听在3000端口。 是的你没看错，这就可以看到效果了，真的是我用过的最简单的搭建方式。 以前用vue-cli的时候的webpack提供的主要功能都实现了。比如热更新，比如自动启动浏览器，比如 npm run build 而且还有eslint 但是是否能配置，怎么配置还要研究一下。 之前用webpack时候，webpack搭建的node服务，解决跨域方式： create-react-app提供了一个超级简单的方法，只需要在package.json文件中，加一个配置项就可以了。 1&quot;proxy&quot;: &quot;http://localhost:3001/&quot; 服务端搭建（模拟接口） node忘完了,这里我只能借助json-server这个工具快速搭建后台管理系统的服务端程序： 安装 1npm i json-server -g 新建目录 根目录下新建一个server目录。server下建要用的json文件比如index.json,然后写入数据。 路由 安装 1npm install react-router-dom --save 新建文件,配置路由。","tags":[{"name":"react","slug":"react","permalink":"https://jiangchengzzz.github.io/tags/react/"}]},{"title":"react学习-webpack搭建（四）","date":"2018-07-10T08:07:55.000Z","path":"20180710/react-learn-4/","text":"添加react-router 安装 npm install react-router-dom –save router有两个版本 用react-router 或者react-router-dom 。这里用react-router-dom，这个模块有几个接口：NavLink 、Route 、BrowserRouter、HashRouter、Swith、Redirect 等 。每个接口的作用我这不做说明。RouteConfig 是路由配置文件，自己创建的。 需要创建一些文件： 在src下创建config文件夹，文件夹里面创建route.jsx,并添加以下内容： 1234567891011121314151617181920212223242526272829303132333435 import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import &#123;NavLink,Route,BrowserRouter as Router,HashRouter,Switch,Redirect&#125; from &apos;react-router-dom&apos;;import MainComponent from &apos;../component/Main.jsx&apos;;//引进组件import Topic from &apos;../component/Topic.jsx&apos;;//引进组件const routes =[ &#123; path:&apos;/&apos;, exact:true, component: MainComponent &#125;, &#123; path:&apos;/topic&apos;, exact:false, component:Topic &#125;,];const RouteConfig = ( &lt;Switch&gt; &#123; routes.map((route,index)=&gt;( &lt;Route key =&#123;index&#125; path=&#123;route.path&#125; exact=&#123;route.exact&#125; component=&#123;route.component&#125; /&gt; )) &#125; &lt;/Switch&gt;);export default RouteConfig; src目录下创建component文件夹，创建以下文件： Main.jsx 1234567891011121314import React from &apos;react&apos;; import ReactDOM from &apos;react-dom&apos;; import &#123;NavLink as Link&#125; from &apos;react-router-dom&apos;; class MainComponent extends React.Component&#123; render()&#123; return( &lt;div&gt; &lt;h1&gt;mainText&lt;/h1&gt; &lt;Link to=&quot;/topic&quot;&gt;jumpe to Topic&lt;/Link&gt; &lt;/div&gt; ); &#125; &#125; export default MainComponent; Topic.jsx 123456789101112131415import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import &#123;NavLink as Link&#125; from &apos;react-router-dom&apos;;class Topic extends React.Component&#123; render()&#123; return( &lt;div&gt; &lt;h1&gt;topicText:&lt;/h1&gt; &lt;Link to=&quot;/&quot;&gt;jumpe to Main&lt;/Link&gt; &lt;/div&gt; ); &#125;&#125;export default Topic; 嗯，应该没问题了。打开浏览器查看就可以跳转路由了。 react+redux Redux模块可以集中管理一些状态。 安装 npm install redux react-redux react-router-redux redux-thunk –save 在src目录下创建一个store文件夹，然后分别创建： store.jsx: 12345678910import &#123;createStore,combineReducers,applyMiddleware&#125; from &apos;redux&apos;;import RootReducer from &apos;./reducer.jsx&apos;;//引入reduceimport ReduxThunk from &apos;redux-thunk&apos;;//中间件var store = createStore( //自动生成store的函数 RootReducer, //reduce,修改state状态的函数集合 applyMiddleware(ReduxThunk) //中间件);export default store; action.jsx: 12345678910111213141516const actions = &#123;changeText:function(num)&#123; console.log(&quot;调用actions&quot;); switch(num)&#123; case 1: return &#123;type:&apos;AlterMain&apos;,payload:&quot;mainContainer had been changed&quot;&#125;; case 2: return &#123;type:&apos;AlterTopic&apos;,payload:&quot;topicContainer had been changed&quot;&#125;; default: return action; &#125;&#125;,&#125;;export default actions; reducer.jsx: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import &#123;combineReducers&#125; from &apos;redux&apos;;import &#123;routerReducer&#125; from &apos;react-router-redux&apos;;const defaultState = &#123;//设定state的默认值mainText:&quot;mainContainer&quot;,topicText:&quot;topicContainer&quot;&#125;;const reducer = (state = defaultState, action) =&gt; &#123; switch (action.type) &#123;//通过action的返回值来选择更新哪个state的状态 case &apos;AlterMain&apos;: return Object.assign(&#123;&#125;,state,&#123; mainText:action.payload&#125;); case &apos;AlterTopic&apos;: return Object.assign(&#123;&#125;,state,&#123; topicText:action.payload&#125;); default: return state; &#125;&#125;;const RootReducer = combineReducers(&#123;//可以定义多个reducer，然后通过combineReducers来合并 routing:routerReducer,//redux和router处理函数 app:reducer //app 需要与组件里面上传的state一致&#125;);if (typeof Object.assign != &apos;function&apos;) &#123;// Must be writable: true, enumerable: false, configurable: trueObject.defineProperty(Object, &quot;assign&quot;, &#123; value: function assign(target, varArgs) &#123; // .length of function is 2 &apos;use strict&apos;; if (target == null) &#123; // TypeError if undefined or null throw new TypeError(&apos;Cannot convert undefined or null to object&apos;); &#125; var to = Object(target); for (var index = 1; index &lt; arguments.length; index++) &#123; var nextSource = arguments[index]; if (nextSource != null) &#123; // Skip over if undefined or null for (var nextKey in nextSource) &#123; // Avoid bugs when hasOwnProperty is shadowed if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) &#123; to[nextKey] = nextSource[nextKey]; &#125; &#125; &#125; &#125; return to; &#125;, writable: true, configurable: true&#125;);&#125;export default RootReducer; 更改组件中的代码 Main.jsx: 1234567891011121314151617181920212223242526272829303132333435363738import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import &#123;NavLink as Link&#125; from &apos;react-router-dom&apos;;import &#123;connect&#125; from &apos;react-redux&apos;;import P from &apos;prop-types&apos;;import actions from &apos;../src/action/action.jsx&apos;;//引入actions//mapstoreStateToProps 这里指定Main控件需要上传的stateconst mapStoreStateToProps = (state) =&gt;( &#123; mainText:state.app.mainText, //mainText是变量，值对应的state.app.mainText的存储空间，其中app与reducers里面定义的一致。 &#125;);//mapDispatchToProps 这里上传处理state函数，即action里面定义的函数const mapDispatchToProps = (dispatch,ownProps)=&gt; (&#123;fn:&#123; changeText:(num)=&gt; dispatch(actions.changeText(num))&#125;&#125;);//这样state一致上传到store，需要取值用props取就okclass MainComponent extends React.Component&#123; render()&#123; return( &lt;div&gt; &lt;h1&gt;mainText:&#123;this.props.mainText&#125;&lt;/h1&gt; &lt;button onClick=&#123;()=&gt;this.props.fn.changeText(1)&#125;&gt;修改mainText的值&lt;/button&gt; &lt;Link to=&quot;/topic&quot;&gt;jumpe to Topic&lt;/Link&gt; &lt;/div&gt; ); &#125;&#125;//最后调用connect函数，把组件和store连接起来export default connect(mapStoreStateToProps,mapDispatchToProps)(MainComponent); Topic.jsx: 12345678910111213141516171819202122232425262728293031323334353637import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import &#123;NavLink as Link&#125; from &apos;react-router-dom&apos;;import &#123;connect&#125; from &apos;react-redux&apos;;import actions from &apos;../src/action/action.jsx&apos;;const mapStoreStateToProps = (state) =&gt;( &#123; topicText:state.app.topicText, &#125;)const mapDispatchToProps = (dispatch,ownProps)=&gt; (&#123;fn:&#123; changeText:(num)=&gt; dispatch(actions.changeText(num))&#125;&#125;);class Topic extends React.Component&#123; render()&#123; return( &lt;div&gt; &lt;h1&gt;topicText:&#123;this.props.topicText&#125;&lt;/h1&gt; &lt;button onClick=&#123;()=&gt;this.props.fn.changeText(2)&#125;&gt;修改topicText的值&lt;/button&gt; &lt;Link to=&quot;/&quot;&gt;jumpe to Main&lt;/Link&gt; &lt;/div&gt; ); &#125;&#125;export default connect(mapStoreStateToProps,mapDispatchToProps)(Topic); 流程可以简化理解为： 组件-&gt;action-&gt;dispath(action)-&gt;store-&gt;reducer -&gt;store(修改state)-&gt;组件（view） 以上只是简单搭建出router与redux实现 最后结果 嗯，简单的webpack4+react+redux就完成了 但是你会发现打包时候会有警告 这是因为上篇提到的dll没装成功，导致压缩后文件过大，webpack就报了警告。 嗯，eslint和dll我研究下会补上的，嗯。 总结 首先，我也是react和webpack新手，只是想学习一下搭建，所以把自己的搭建过程，写出来，既然是小白当然是看教程喽。 然后就需要感谢这位兄弟的博客，https://github.com/webpack/docs/wiki/configuration#devtool 因为我是基本借（zhao）鉴（ban）他的搭建过程，加上自己的一些习惯，以及升级webpack4.x的一些更改。","tags":[{"name":"react","slug":"react","permalink":"https://jiangchengzzz.github.io/tags/react/"},{"name":"webpack","slug":"webpack","permalink":"https://jiangchengzzz.github.io/tags/webpack/"}]},{"title":"react学习-webpack搭建（三）","date":"2018-07-07T09:24:38.000Z","path":"20180707/react-learn-3/","text":"添加babelES6 转ES5模块 首先肯定是引入 npm install babel-loader babel-core babel-preset-env webpack –save-dev 如果要支持react，需要安装下面的模块： npm install babel-preset-es2015 babel-preset-react babel-preset-stage-3 –save-dev webpack.config.js 的rule中添加代码： { test:/\\.jsx$/, exclude:/(node_modules|bower_components)/,//排除XXX类型文件 use:{ loader:&apos;babel-loader&apos; } } 根目录下创建.babelrc文件添加如下代码： { “presets”: [“es2015”,”react”]} 添加url和file模块 引入 npm install url-loader file-loader –save-dev webpack.config.js 的rule中添加 最基本的搭建已经完成了，下面是高级篇。 webpack4.x移除了之前必要的UglifyjsWebpackPlugin压缩，所以现在不需要添加相关配置。只需要在package.json中的script中添加： “build”: “webpack –mode development”以后就可以用npm run build进行压缩了。 devtool webpack 提供的辅助工具，调试的时候能正确的显示源代码出错的行数。eval-soure-map用于开发模式下,其他模式 devtool:’eval-soure-map’ happypack 让loader多进程去处理文件，加速webpack构建 npm install happypack –save-dev在webpack.config.js三个部位中添加： eslint 普通规则可以，但是airbnb 我报错了后期补上。 dll 不好意思，我报错了后期补上。 然后是加入react组件 先用node.js安装react 和react-dom 模块: npm install react react-dom –save添加react代码： 最后 总结： 其实很重要的eslint和dll没成功有点烦，特别是dll 不知道为什么试了那么多帖子上的方法都失败， 嗯，下次有时间在来补； 然后就需要感谢这位兄弟的博客，https://github.com/webpack/docs/wiki/configuration#devtool","tags":[{"name":"react","slug":"react","permalink":"https://jiangchengzzz.github.io/tags/react/"},{"name":"webpack","slug":"webpack","permalink":"https://jiangchengzzz.github.io/tags/webpack/"}]},{"title":"vue路由跳转用router-link的好处","date":"2018-07-07T06:11:46.000Z","path":"20180707/router-link/","text":"具体情况 在用vue的时候写了个头部组件， 在index.vue中引入， 需要对不同角色做权限控制， 直接写点击事件来进行跳转，条件判断类名的形式。显示状态 出现的问题 浏览器刷新时候，选中状态不显示， 想了有几种方案： 用vuex去存当前跳转的路由，通过在组件循环获取 同上用stroage去存 但是感觉都太繁琐，后来发现如果路由跳转用router-link，vue-router会帮你把路由与router-link绑定，你只需要去设置当路由adtive时候所需要增加的class就好还可以吧router-link指定为其他标签例如： 文档：详情请看https://router.vuejs.org/zh/api/#linkactiveclass 解决的问题，以及好处 用了router-link标签后发现： 不论是手输路由，还是刷新页面，路由选中状态都不会消失。 简化了之前自己添加类名触发点击事件中的各种循环，以及自己添加的各种字段。 感觉自己变帅了。","tags":[{"name":"vue-router","slug":"vue-router","permalink":"https://jiangchengzzz.github.io/tags/vue-router/"},{"name":"vue","slug":"vue","permalink":"https://jiangchengzzz.github.io/tags/vue/"}]},{"title":"react学习-webpack搭建（二）","date":"2018-07-05T02:28:27.000Z","path":"20180705/react-learn-2/","text":"配置升级篇 引入自动生成html的插件： 安装 npm install html-webpack-plugin –save-dev 配置webpack.config.js,引入模块，并在module.exports 设置plugins对象值 webpack引入node.js的express服务器来支持热更新。 安装 npm install webpack-dev-server –save-dev 可以直接在webpack.config里面配置,首先要在package.json内配置 “scripts”:{ &quot;start&quot;:&quot;webpack-dev-server --inline --hot&quot; } // 嗯，就是脚手架那种npm start启动 然后webpack.config.js 里面的配置： 新建一个webpack.server.js,package.json内配置,指定对应文件 “scripts”: { “start”:”node server.js” }, 然后webpack.server.js 里面的配置： 嗯，现在是各种文件的支持。 webpack是基于nodeJS平台，完全支持JS文件不支持css。所以要把css转成JS文件。webpack提供了一个两个模块来支持css文件转编译。 1234style-loader:将css内容插入到html的style css-loader:处理css里面的@import 和url() 的内容，需要url-loader 和file-loader的支撑 file-loader: 用MD5 hash加密文件名后返回相应的路径 url-loader 在file-loader 基础上加了额外的功能。当链接的文件小于limit 8192时，可以直接返回DataURL。DataURL是图片格式转换成base64编码的字符串，并存储在URL中。这样可以减少客户端的请求次数 安装 npm install css-loader style-loader –save-dev npm install url-loader file-loader –save-dev 修改webpack.config.js 的配置 肯定实在src下面创建各种文件夹和文件了，以及app.js导入文件了，以下是我的：（包括后面用的sass和less，这边不需要）,嗯，还有里面随便写的样式。app.js 目录css，scss，less。 然后就是npm start了，去浏览器进你配的localhost:XXXX； 现在到了打包剥离css文件环节，css文件和html混合，这不符合html的优化思路。 所以要求webpack生成的最终文件css也是单独一个文件。这里webpack提供了 extract-text-webpack-plugin插件 安装 npm install extract-text-webpack-plugin –save-dev 修改webpack.config.js还有webpack.config.js顶部引入的文件，截图截不下额。 const ExtractTextPlugin = require(‘extract-text-webpack-plugin’) 停掉服务器，然后webpack打包就可以看到build文件夹里有style.css了。 是不是很开心!因为报错了，如果你的webpack版本是4.0以上 Chunk.entrypoints: Use Chunks.groupsIterable and filter by instanceof Entrypoint instead extract-text-webpack-plugin还不能支持webpack4.0.0以上的版本 This is 官方给的说法 解决方法npm install –save-dev extract-text-webpack-plugin@next 会下载到extract-text-webpack-plugin@4.0.0-beta.0 但是不知道为什么我下下来了也可以用，但是没有显示在package。 自己折腾时候还遇到了Cannot find module ‘import-local’这种错，然后在这个文件夹下webpack -v 都会报这个错，实在没办法最后只能删除这个node_modules然后删除package.json中所有关于webpack的，然后重新安装。。。。然后就好了，尴尬。 现在就是在项目中用sass和less 嗯，要安装的东西 npm install sass-loader node-sass webpack –save-devnpm install less-loader less –save-devnpm i -D postcss-loader 在根目录上创建postcss.config.js（webpack 会自动找到这个文件):里面写 module.exports = {plugins:{‘autoprefixer’: {},} webpack.config.js 里面配置: 搞定了嗯，是的有点丑。 总结： 其实很重要的eslint和dll没成功有点烦，特别是dll 不知道为什么试了那么多帖子上的方法都失败， 嗯，下次有时间在来补； 然后就需要感谢这位兄弟的博客，https://github.com/webpack/docs/wiki/configuration#devtool","tags":[{"name":"react","slug":"react","permalink":"https://jiangchengzzz.github.io/tags/react/"},{"name":"webpack","slug":"webpack","permalink":"https://jiangchengzzz.github.io/tags/webpack/"}]},{"title":"react学习-webpack搭建（一）","date":"2018-07-04T06:19:44.000Z","path":"20180704/react-learn-1/","text":"初衷 嗯，最近工作内容比较少，是时候补充下自己了，纠结了一天该学什么， react、node、nginx、typescript，竟然有这么多。 反正都有这么多，就先从react开始吧！ 说明 我也是react和webpack新手，只是想学习一下搭建，所以把自己的搭建过程，写出来。 https://github.com/webpack/docs/wiki/configuration#devtool ，我是看着这位前辈的博客搭建的，原文比我的更加详细，但是如果升级了webpack4.会有几个问题。准备我选择的是用webpack进行搭建环境，然后发现自己搭建webpack基本忘完。嗯所以第一篇就重新学一遍webpack搭建。 webpack搭建初级： 首先肯定是全局安装webpack npm install webpack -g 然后就是建项目文件夹，打开命令行（目录下shift+右键）或者gitbash。 npm init 再后那就是在这个根目录下创建个webpack.config.js文件以及基本项目目录,下面是我的目录以及配置信息。 src文件夹下面建app.js,随便写点什么例如：alert(‘你好萌啊’);，src下再创建一个index.html引入bundle.js文件。（还未生成，后面会生成只是先写 安装本地webpack包 npm install webpack –save-dev//功后显示Hash: bba9fbe70c8f6bbe2cd1Version: webpack 3.3.0Time: 47ms Asset Size Chunks Chunk Namesbundle.js 2.58 kB 0 [emitted] main[0] ./src/app.js 111 bytes {0} [built] 访问index.html 就能看到app.js里面写的东西了。","tags":[{"name":"react","slug":"react","permalink":"https://jiangchengzzz.github.io/tags/react/"},{"name":"webpack","slug":"webpack","permalink":"https://jiangchengzzz.github.io/tags/webpack/"}]},{"title":"第一篇博文，联系markdowm，写下博客搭建过程。","date":"2018-07-02T09:32:42.000Z","path":"20180702/first-blog-construct/","text":"初衷嗯，学的东西都忘完了，准备记录一下，早就想搭了啊，嗯，记性不好人还懒。 准备其实早就开始准备了，因为找模板都比较丑，主要因为懒，就拖到现在 过程有点蠢 第一阶段 node.js+git环境 建好github博客 绑定域名（没钱买，所以没绑） 第二阶段 安装hexo 1$ npm install -g hexo 初始化，建个文件夹，进入执行 1$ hexo init 初次生成 12$ hexo g #生成$ hexo s #启动服务 按照命令行提示浏览器进入localhost:4000 1有些4000端口会被占用,就要杀掉占用中（百度一下，你就知道）的或者修改端口 server: port: 4112 compress: true header: true 第三阶段 修改主题官方主题， 或github上面搜呗hexo themes 大把 修改_config.yml中的theme: landscape改为theme: yilia，然后重新执行hexo g来重新生成（若出现看不懂的问题执行hexo clean再生成） 第四阶段 上传so easy 直接执行hexo d123456789当然会有问题啦: 要在_config.yml中p配置deployb部分 deploy: type: git repository: git@github.com:liuxianan/liuxianan.github.io.git branch: master还是有问题： 要安装一个插件: npm install hexo-deployer-git --save 常用命令 1234567891011121314151617hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本一些缩写：hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy组合命令:hexo s -g #生成并本地预览hexo d -g #生成并上传 感受不够熟练写的超级慢啊，找模板有点蒙蔽，一个比一个丑。 补嗯昨天弄完发现文章分类，标签预览啥都有，就是不能看全文，曰了狗。 12搞了一个多小时都搞不定，最后用了最简单暴力的方式，重装，so easy！","tags":[{"name":"杂记","slug":"杂记","permalink":"https://jiangchengzzz.github.io/tags/杂记/"}]}]